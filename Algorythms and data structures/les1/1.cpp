#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
using namespace std;
//Жадные Алгоритмы и динамическое программирование
// обе задачи нужны для нахождения оптимального решения
// проблема - для нахождения оптимального решения достаточно сделать оптимальное решение - подход работает не всегда
// решение часто придумать можно, но самое сложно - доказать что жадный шаг приводит к оптим. решению
// Если можно задачу решить и ЖА и ДП, то Ж будет и по времени и по памяти быстрее
// #1 типичная задача - прямая с точками дана, дан отрезок длины, надо покрыть так, чтобы все точки
// находились внутри отрезков, и использовать минимальное количество отрезков
// есть неск оптимальных решений
//        |_____| |_____| |_____|
// ________.___.___._.____._______
// Жадный шаг в этой задаче какой?
// Берем первую точку, от нее отсчитываем отрезок и покрываем максимальное кол-во точек нашим отрезком
// (полезнее всего пользуемся длиной отрезка) - и так далее; O(nlogn) по времени, через сортировку подсчетом
// можно добиться O(n)
// прога:
int min_sec(vector<int> &v, int L) {
    //sort(v.begin(), v.end()); скучно, O(nlogn)
    auto max_el_it = max_element(v.begin(), v.end());
    int max_el = *max_el_it;

    vector<int> cnt(max_el);
    for (int i=0; i<v.size(); i++) { 
        cnt[v[i]]+=1;
    }
    vector<int> v_sort;
    for (int i=0; i<v.size(); i++) {
        if (cnt[i]>1) {
            for (int j=0; j<cnt[i]; j++) {
                v_sort.push_back(i);
            }
        }
        else if (cnt[i]==1) {v_sort.push_back(i);}
    }

    int ans=0;
    for (int i=0; i<v_sort.size(); i++) {
        //
        //дописать
        //
    }
    return ans;
}

int main(){
    int n; cin>>n; int l; cin>>l;
    vector<int> v(n);
    for (int i=0; i<n; i++) {
        cin>>v[i];
    }
    int ans = min_sec(v,l);
    cout<<ans;
    return 0;
}
// #2(cложная) приходит вектор, значения в нем - максимальный прыжок на который мы можем прыгнуть
// [3|4|1|1|0] можно решить дп, можно жадно O(n)

// #3 КОД ХАФФМЭНА
// подается строка каких-то символов, надо ее закодировать минимальным кол-вом символов(char 1byte)
// abcddcdd 8 букв, строим бинарное дерево выгодное - d:0 a:10 c:110 d:111
// надо получить строку, придумаь для нее код, зашифровать, и еще вспоминаем половину прошлого семестра
// хорошая идея отсортировать, использовать дерево, внутри листьев - символ и частота, внутренние узлы - :кол-во
// берем два листа с минимальной частотой, склеиваем и все получается 
// чего мы должны какой-то компаратор сделать ....
// очередь с приоритетом - куча, ее основное свойство - потомки не больше родителей
// частота меньше - идем в лево, частота больше - идем в право
string code_haffman(const string &str) {

}