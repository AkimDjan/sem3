//напишем DFS для обхода графа
#include <iostream>
#include <vector> 
#include "graph.h"
//знаем что такое enum - перечисление, c++11 пофиксил одну вещь
using namespace graph;


enum class Colors { 
    White, //не посещалась
    Gray, //начали обрабатывать
    Black //все исходящие пути обработали
};
// на самом деле enum'ы строго привязаны к интам, они будут 0;1;2
// можно самим пронумеровать
// Придумали enum'ы чтобы не хардкодить, мы как бы не бегаем по всему коду и только в енуме меняем число
// это было хорошо, а плохо - неявное приведение типов инта к enum, иногда стреляло в ногу
// чтобы привести от одного к другому надо явно говорить static cast, не ловим логические ошибки исполнения,
// пытаемся все заносить в ошибки компиляции
// пишем DFS
void GoDFS(Vertex v, std::vector<Colors>& colors, const Graph& gr) {
    switch(colors[v]){
    case Colors::White:
        colors[v]=Colors::Gray;
        std::cout<<"passed\n";
        for (Vertex w : gr.GetAdjacents(v)){
            GoDFS(w, colors, gr);
        }
        colors[v]=Colors::Black;
        break;
    case Colors::Gray:
        std::cout<<"Has cycle at: "<<v<<"\n"; //Если граф ориентированный - пойман цикл
        break;
    case Colors::Black:
        std::cout<<"Has competed vertex at: "<<v<<"\n";
        break; // не было бы брейков перешло бы к следующим
    }
}

void DFS(const Graph& gr){
    std::vector<Colors> colors(gr.size(), Colors::White);
    for (Vertex v=0; v<gr.size(); ++v){
        if (colors[v]==Colors::White) {
            GoDFS(v, colors, gr);
        }
    } 
}

//O(|V|+|E|)

//Дебильники...........................
// сильные и слабые связности - 
// Ориентированный граф называется сильно связным, если для любых двух вершин 
// u и v существует путь из u в v И путь из v в u.
// Цикл - необходимое условие, для того, чтобы у ориентированного графа была сильная связь
// у графа можно взять ориентированность поменять на неориентированность и граф будет связным - слабая связь

// чтобы найти количество компонент слабой связности - получаем из ориентированного неориентированный граф
// и количество запущенных на белом дфс- количество связностей слабых

// для нахождения сильных связностей достаточно 2 дфс
// этот алгоритм есть в 2 формах
// 1) тот же пример , инвертировали ребра
// 2) запускаемся с последней вершины DFS и будем ставить черну метку
// 3) Дошли до конца, в обратном порядке располагаем номера от 1
// 4) Запускаем DFS на оригинальном графе и берем как со стэка снимаем так и запускаем 
// 5) считаем количество DFS - получили 2 компоненты сильной связности 

// дз мда, 
// есть граф, есть DFS, нужна инвертация чтобы реализовать алгоритм Касарайю
// легче всего инвертировать когда есть матрица смежности
// добавить новый метод get_invert_matrix, сказать за сколько будет работать 

// еще один интересный вопрос 
// getAdjacent возвращает ссылку
// как изменилось бы время работы если убрать амперсант? 
// O(V^2+E) :(
// получили бы квадратичное увеличение из-за опечатки 
// на этом заканчивается 1 часть - дп, жадные алгоритмы, представления графов и обходы графов
// переходим ко 2 части - поиск путей 
 
// дан невзвешенный граф
// расстояние измеряется в количестве ребер
// волновой алгоритм = BFS с метками
// если есть взвешенный граф - все ребра неотрицательные 
// Волновой алгоритм с метками можно расширить на взвешенный
int main() {
    return 0;
}