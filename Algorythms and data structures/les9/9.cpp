#include <iostream>
#include <vector>
using namespace std;

int n;
vector<vector<int>> d;
// Алгоритм Флойда Уоршелла
// d[i][j][k]
// путь из i в j проходя через 0.. k
// выбираем как:
// d[i][j][k] = min(d[i][k][k-1],d[i][k][k-1] + d[k][j][k-1])
// чтобы решить эту задачу надо пройтись по всем k по всем вершинам
// вообще говоря - есть матрица смежности с весами (беск. если ребер нет, веса если есть)
// на основании k-1 шага мы делаем следующую матрицу - пример
// (  0     3   беск   2  )
// (беск    0     5   -2  )
// (беск   -1     0  беск )
// (  1   беск  беск   0  )
// теперь матрица при k=2
// (  0     3     8    1  )
// (  2    0     5   -2  )
// (беск   -1     0   -3  ) 
// (  1     7   беск   0  )
//
// (  0     3   беск   1  )
// (беск    0     5   -2  )
// (беск   -1     0  беск )
// (  1   беск  беск   0  )
vector<vector<int>> prev;
vector<int> path;



int main(){
    for (int k=0; k<n;k++) {
        for (int i=0; i<n;i++) {
            for (int j=0; j<n;j++) {
                if (d[i][k]+d[k][j]<d[i][j]){
                    
                }
                d[i][j] = min(d[i][j],d[i][k] + d[k][j]);
                //круто

            }
        }
    }
}
// бесконечность аккуратно потому что переполнение будет если взять climits
// первый вариант - 1e9
// второй вариант - написать тип inf 
// восстановление путей
// в отличие от дейкстры - любой с любым ищем минимальный путь 
// задача про арбитраж валют
// x y валюты, x1/x2*x2/x3*xn/x`1 = 0 ; x1/x`1<1
// ищем отрицательный цикл... изварещнская, а алгоритм - извращенкий
