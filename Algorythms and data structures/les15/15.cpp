// проверка планарности графа 
// граф не планарен если он изоморфен графу к5 и к3,3
// гамма алгоритм дает ответ на вопрос планарен ли граф
// если односвязный (с одной компонентой связности) граф с циклом - гамма алгоритм
// Также в графе не должно быть мостов
// если в графе нет цикла - то это дерево, тем самым мы его можем сделать планарным
// гамма алгоритм это про цикл односвязный
// на него в целом уделялось 2 пары но сегодня поразмыслить сможем
// первым делом пускаем обход и находим цикл
// нашли какой-то цикл
// он разбивает наше пространство на 2 грани - грань1 и грань 2 (внутри цикла и вне цикла)
// те ребра которые остались - выписываем их (которые не в цикле)
// далее сегменты начинают укладываться в туда - в какие-то грани
// мы для каждого цикла выбираем в какие он грани может уложиться
// пока они все могут уложиться в грани
// берем сектор с наименьшим количеством куда он может уложить, при этом образуются новые грани и при этом мы можем уложить
// реализовывать его довольно муторно
// мы вбираем тот который меньше и укладываем
// полностью решать не будем, но нам нужна табличка какой сегмент изменился, делиться и апдейтить
// про паттерны проектирования немного было, наблюдателя вспомним
// у нас есть какое-то событие и надо оповестить множество элементов каких-то. Собственно говоря для этого и есть
// ооп, функциональное
// interface - класс который говорит что мы можем делать, абстрактный класс с виртуальными функциями
// 
class Context {};

class IObserver {
public:
    virtual ~IObserver() {};
    virtual void AddSubscr(ISubscriber* sub)=0;
    virtual void EraseSubscr(ISubscriber* sub)=0;
    virtual void Notify()=0;
};

class ISubscriber{
    virtual ~ISubscriber() {};
    virtual void Update(Context cntxt) {};
};