// В прошлый раз работали с деревом отрезков, допустим на массиве заданы чиселки
// выполняем некоторые запросы с ассоциативными операциями( сумма максимум минимум, нод)
// поговорим про апдейт и посмотрим какие другие есть способы кроме деревьев отрезков чтобы подобные задачи решать
// 1) помним как строится, есть какой-то исходный массивчик 
// [10 9 7 4 5 2 -беск. -беск.]
// 10 7 5
// 10 5
// 10
// расширенный массив 
// как происходил апдейт ? Если один элем меняется, то рекурсивно пойдем вверх и апдейтить наши значения (займет логарифм)
// [10 9 7 11 5 2 -беск. -беск.]
// 10 11 5
// 10 11
// 11
// 2) Если весь отрезок - тогда можем проапдейтить все через while
// помним что сейчас говорю про сверху вниз (можно через снизу вверх - рекурсия)
// интересная задачка, когда нужно просто изменить какой-то диапазон насколько-то, пусть прибавить
// в задачах статистики (на отрезке добавить какое-то число и посмотреть как измениться)
// здесь больше подойдет сверху вниз , говорим на сколько апдейтить и какой интервал, и тем детям где идет апдейт 
// меняем там где надо и до листочков доходим и все хорошо
// поговорили про апдейты
// Один из подходов (Николай ворчал из-за того что я говорил на примере суммы разбирал дерево отрезков)
// есть префиксные суммы - условие 
// почему префиксные суммы не могут заменить статичное дерево отрезков? из-за обновления
// Префиксные суммы когда дан массивчик какой-то
// 10 1 17 5
// 10 11 28 33
// если какую-то конкретную сумму надо вывести тогда просто вычитаем 
// Префиксные суммы работают со всем для чего есть обратная операция 
//
// Разреженные таблицы
// связаны с суммированием
// надо чуть извратить алгоритм
// есть требование что a () a = a
// работают с максимумом минимум и подобными, наименьшим общим делителем
// как они строятся следующим образом
// 1 1 2 7 5 9 - 2 ** 0
// 1 2 7 7 9 - 2 ** 1 
// 1 7 9 - 2 ** 2
// 2**3 не будет 
// пусть 1 1 2 7 5 9 13 - 2 ** 0
// 1 2 7 7 9 13 - 2 ** 1 
// 1 7 9 13 - 2 ** 2
// мы находим ту степень двойки которая не больше того числа что у нас попалось
// левый индекс (надо будет сравнить неск подмассивов )
// первый тк разряжанная таблица индекс совпадает с левой границей 
// R - самый правый индекс => R - 2 ** i + 1 
// сравниваем эти 2 числа ( 9 и 13) и все хорошо
// ну и почему тут с суммами не проработать - тут перекрывающиеся массивчики, нек вещи указывались 2 раза, там
// бы еще проход убрать все лишнее надо было б 
// если вам что-то и потребуется - то деревья отрезков, из интересного хочу сказать что 
// во всяком машинном обучении есть вложенность трехмерных структур друг в друга с помозью деревьев отрезков
// программу примерно всю дал, но LCA нет (по дереву найти от самого дальнего от корня общего предка)
// в пт онлайн (гугл тесты)
// в субботу программу алгоритмов расскажет, было в предыдущих годах (док-во планарности графов, интересная вещь)
// всю субботу будем разговаривать про гамма алгоритм