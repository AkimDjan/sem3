// Дана матрица N × M, положительных натуральных чисел, где каждая ячейка содержит монету 
// определенного номинала (число ячейки = номинал), “пройдясь” по матрице соберите монетки
// с максимальной конечной суммой.
// Правила проходов: Первый проход начинается с верхнего левого угла матрицы и заканчивается
// в нижнем левом углу, а второй проход начинается с верхнего правого угла и заканчивается в
// нижнем правом углу. Из любой ячейки (i, j) в матрице нам разрешено перейти в ячейку (i+1, j+1)
// или (i+1, j-1) или (i+1, j). Если оба обхода проходят через одну и ту же ячейку, только один 
// может собрать монету из этой ячейки.

// Формат ввода
// В первой строке записаны через пробел два натуральных числа N, M - размер исходной матрицы. В последующих M строках через пробел записано N чисел - исходная матрица.

// Формат вывода
// Одно натуральное число - итоговая сумма.

// Пример
// Ввод
// 4 5
// 0 2 4 1
// 4 8 3 7
// 2 3 6 2
// 9 7 8 3
// 1 5 9 4
// Вывод
// 47

// Идея - Мы рассматриваем оба прохода одновременно и считаем динамикой максимальную сумму монет, 
// если оба прохода находятся на одной и той же строке, но в разных столбцах

#include <iostream>
#include <vector>


using namespace std;


int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int N, M;
    if (!(cin >> N >> M)) {
        return 0;
    }

    vector<vector<long long>> a(M, vector<long long>(N));
    for (int i = 0; i < M; ++i) {
        for (int j = 0; j < N; ++j) {
            cin >> a[i][j];
        }
    }

    const long long NEG_INF = (long long)-4e18;

    vector<vector<vector<long long>>> dp(
        M, vector<vector<long long>>(N, vector<long long>(N, NEG_INF))
    );

    dp[0][0][N-1] = a[0][0] + (0 == N-1 ? 0 : a[0][N-1]);

    for (int i = 1; i < M; ++i) {
        for (int j1 = 0; j1 < N; ++j1) {
            for (int j2 = 0; j2 < N; ++j2) {
                long long best_prev = NEG_INF;

                for (int dj1 = -1; dj1 <= 1; ++dj1) {
                    int pj1 = j1 + dj1;
                    if (pj1 < 0 || pj1 >= N) continue;

                    for (int dj2 = -1; dj2 <= 1; ++dj2) {
                        int pj2 = j2 + dj2;
                        if (pj2 < 0 || pj2 >= N) continue;

                        best_prev = max(best_prev, dp[i-1][pj1][pj2]);
                    }
                }

                if (best_prev == NEG_INF) {
                    dp[i][j1][j2] = NEG_INF;
                    continue;
                }

                long long add = a[i][j1];
                if (j1 != j2) add += a[i][j2];

                dp[i][j1][j2] = best_prev + add;
            }
        }
    }
    long long ans = dp[M-1][0][N-1];
    cout << ans << "\n";
    return 0;
}
