#include <vector>
#include <iostream>
// на прошлом занятии поговорили про остовное дерево
// остовное дерево - подграф связного графа, включающий все его вершины, но не содержащий циклов
// поговорили про построение, про систему непересекающихся множеств
// ассоциативные операции (a + b) + c = a + (b + c) 
// сложение , умножение, максимум, минимум, объединение и пересечение множеств, наименьший общий делитель
// дерево отрезков 0.0
// есть массив из каких-то эллементов и на нем будем запрашивать какую-то ассоциативную операцию
// rsq, rmq = ranged sum query, range maximum query
// Для простоты сумму считаем - 1 5 8 9 7 6 4 9 
// попарно суммируем - 6 17 13 13
// 23 26
// 49 - то, что написано - дерево отрезков
// пусть берем массив 5 8 9 7 6 4 9
// мы хотим в среднем логарифмическое время 
// значит надо взят 5 + 17(сумма двух) + 26(сумма 4)
// Сверху вниз - приходят индексы 0 1 2 3 ... 7, приходит 1 3 - идем влево, и после ищем
// есть дерево отрезков - как мы будем его хранить - как массив. Заполняется слева направо
// на примере размер 2**n - надо на сумму добавить 0, произведение - 1
// есть массив n'<= 2**n, добиваем тем что не нарушает ассоциативность
// 2**n = n . либо массив нужен 2n-1, либо 4n' но тут будет много не заюзанной памяти и тд 
// узлы - parent, left, right
// индексы будут заходить на исходном массиве, а произошла перенумерация. нужна операция как получить из исходного
// массива как оно приходило 
// нерекусривный конструктор - дз !!!
class SegmentTree{
public:
    segmentTree(const std::vector<int>& vec); //дз
    Request(size_t left, size_t right);
    //update - задача со *
private:
    std::vector<int> segment_tree; // 2n-1
    size_t parent(size_t i);
    size_t get_new_index(size_t i) {return n - 1 + i;} 
    size_t n; //2^k
    int Request(size_t left, size_t right) {
        size_t Left = get_new_index(left);
        size_t Right = get_new_index(right); // начинаем двигаться вверх
        int ans = 0;
        while (Left < Right) {
            if (Left % 2 == 0) {ans += segment_tree[Left]; Left++;}
            if (Right % 2 == 1) {ans += segment_tree[Right]; Right--;}
            Right = parent[Right];
            Left = parent[Left];
        }
        ans += segment_tree[left];
        return ans;
    }
};